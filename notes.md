# Refactoring Notes

## Main Design Decisions
To transition the codebase into a production-suitable structure, I adopted a **Layered Architecture** that strictly separates the presentation layer (`routers` and `schemas`) to handles HTTP requests/responses and input validation using Pydantic, business logic (`rag_workflow` and `embedding_service`) contains core LangGraph workflow and data transformation logic, and data access layer (`database`). I implemented an abstract base class (`DB`), which standardizes the contract for both the Qdrant and In-Memory implementations, allowing them to be swapped easily without affecting the business logic. Furthermore, I utilized FastAPI's **Dependency Injection** system to manage the lifecycle of services and configuration, ensuring that components remain loosely coupled and preventing hard-coded dependencies throughout the application. I also prioritized security and flexibility by moving hardcoded credentials into environment variables (`.env`).

## Trade-off Considered
A key trade-off that I consider involved the placement of the document ingestion logic, specifically where to handle ID generation, text embedding, and database storage. I considered encapsulating this within the `RAGWorkflow` class to keep the controller thin, but I rejected this approach because it would unnecessarily couple simple data entry with the complex LangGraph workflow, making unit testing difficult as it would require initializing the full graph just to test storage. I decided to orchestrate the logic directly in the **Router** using injected dependencies even this decision makes controllers "fat", but for this specific context, the logic is linear and simple. This decision keeps the RAG logic focused solely on retrieval and generation while remaining testable, avoiding unnecessary complexity for the current scope.

## Maintainability Improvements
This refactored version significantly improves maintainability by isolating responsibilities, making the codebase easier to navigate and understand. The use of interfaces and dependency injection allows for straightforward unit testing, as the database and embedding services can now be easily mocked without requiring a live Qdrant instance. Additionally, the modular structure ensures that future changes, such as switching vector databases or modifying the RAG strategy, are contained within specific files, drastically reducing the risk of causing breaking existing functionality in unrelated parts of the system.